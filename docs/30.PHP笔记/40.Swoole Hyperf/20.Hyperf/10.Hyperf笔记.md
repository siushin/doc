---
date: 2025-08-15 00:11:15
permalink: /php/Hyperf
categories:
  - Swoole
  - Hyperf
tags:
  - Swoole
  - Hyperf
---

# Hyperf笔记

## 宝塔部署Hyperf项目

- 打开该站点配置vhost如下

```text
upstream hyperf {
    # Hyperf HTTP Server 的 IP 及 端口
    server 127.0.0.1:9501;
}

server {
    # 监听端口
    listen 80; 
    # 绑定的域名，填写您的域名
    server_name test-cloud.foo.cn;

    location / {
        # 将客户端的 Host 和 IP 信息一并转发到对应节点  
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # 转发Cookie，设置 SameSite
        proxy_cookie_path / "/; secure; HttpOnly; SameSite=strict";

        # 执行代理访问真实服务器
        proxy_pass https://hyperf;
    }
}
```

- Hyperf 热更新Watcher

<https://blog.csdn.net/Chen_start02/article/details/121331626>

## 不能通过全局变量储存状态

对于 `global` 变量和 `static` 变量，在 `PHP-FPM` 模式下，本质都是存活于一个请求生命周期内的，而在 `Hyperf` 内因为是 `CLI` 应用，会存在 `全局周期` 和 `请求周期(协程周期)` 两种长生命周期。

- 全局周期，我们只需要创建一个静态变量供全局调用即可，静态变量意味着在服务启动后，任意协程和代码逻辑均共享此静态变量内的数据，也就意味着存放的数据不能是特别服务于某一个请求或某一个协程；
- 协程周期，由于 `Hyperf` 会为每个请求自动创建一个协程来处理，那么一个协程周期在此也可以理解为一个请求周期，在协程内，所有的状态数据均应存放于 `Hyperf\Context\Context` 类中，通过该类的 `get`、`set` 来读取和存储任意结构的数据，这个 `Context(协程上下文)` 类在执行任意协程时读取或存储的数据都是仅限对应的协程的，同时在协程结束时也会自动销毁相关的上下文数据。

## Channel 通道

`Channel` 主要用于协程间通讯，当我们希望从一个协程里返回一些数据到另一个协程时，就可通过 `Channel` 来进行传递。

主要方法：

- `Channel->push` ：当队列中有其他协程正在等待 `pop` 数据时，自动按顺序唤醒一个消费者协程。当队列已满时自动 `yield` 让出控制权，等待其他协程消费数据
- `Channel->pop` ：当队列为空时自动 `yield`，等待其他协程生产数据。消费数据后，队列可写入新的数据，自动按顺序唤醒一个生产者协程。

下面是一个协程间通讯的简单例子:

```php
<?php
co(function () {
    $channel = new \Swoole\Coroutine\Channel();
    co(function () use ($channel) {
        $channel->push('data');
    });
    $data = $channel->pop();
});
```

## Defer 特性

当我们希望在协程结束时运行一些代码时，可以通过 `defer(callable $callable)` 函数或 `Hyperf\Coroutine::defer(callable $callable)` 将一段函数以 `栈(stack)` 的形式储存起来，`栈(stack)` 内的函数会在当前协程结束时以 `先进后出` 的流程逐个执行。

## 通过 #[Inject] 注解注入

使用 `#[Inject]` 注解时需 `use Hyperf\Di\Annotation\Inject;` 命名空间；

## 中间件的执行顺序

有 3 种级别的中间件，分别为 `全局中间件`、`类级别中间件`、`方法级别中间件`，如果都定义了这些中间件，执行顺序为：`全局中间件 -> 类级别中间件 -> 方法级别中间件`。

## 注解

- 使用类注解
- 使用类方法注解
- 使用类属性注解

## Hyperf 里的 AOP

- AOP面向切面编程，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术

- AOP 是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果

- Hyperf 里的 AOP：只需理解一个概念即可，即 Aspect（切面）

- Aspect 可以切入任意类或任意注解类

- 被切入的类必须由 DI管理

- Hyperf 的 AOP 是基于 DI 实现的

- 必须使用的是 Hyperf 的 DI 组件，即 hyperf/di

- 必须通过 DI 创建的对象才能是 AOP 生效，直接 new 不行

- 必须当代理类缓存文件不存在时才会重新生成代理类

### AOP的应用场景

- 参数校验、日志、无侵入埋点、安全控制、性能统计、事务处理、异常处理、缓存、无侵入监控、资源池、连接池管理等
