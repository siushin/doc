---
title: Laravel基础知识
date: 2025-07-16 21:55:03
permalink: /php/laravel
categories:
  - Laravel
tags:
  - Laravel
---

# Laravel基础知识

## Laravel版本时间线

- [Laravel Versions](https://laravelversions.com/zh_CN)

## Laravel学习网站

### Laravel中文网

- [Laravel中文网]<https://laravel.p2hp.com/>

## 安装Laravel命令

```shell
composer create-project laravel/laravel myapp
# 指定版本
composer create-project laravel/laravel=10.* myapp --prefer-dist
```

## 常见的HTTP状态码

### 1xx（信息性状态码）

- 100 Continue: 表示服务器已收到请求的初始部分，并且客户端应该继续发送其余的请求。

### 2xx（成功状态码）

- 200 OK: 表示请求已成功。
- 201 Created: 表示请求已经被成功处理，并在服务器上创建了新的资源。
- 204 No Content: 表示服务器成功处理了请求，但没有返回任何内容。

### 3xx（重定向状态码）

- 301 Moved Permanently: 请求的资源已被永久移动到新位置。
- 302 Found: 请求的资源临时被移动到新的位置。
- 304 Not Modified: 如果请求的资源没有被修改，可以使用缓存的版本。

### 4xx（客户端错误状态码）

- 400 Bad Request: 请求无效，服务器不理解请求的语法。
- 401 Unauthorized: 请求要求身份验证。
- 403 Forbidden: 服务器理解请求，但拒绝执行。
- 404 Not Found: 服务器找不到请求的资源。

### 5xx（服务器错误状态码）

- 500 Internal Server Error: 服务器遇到了一个未知的错误。
- 502 Bad Gateway: 作为网关或代理的服务器从上游服务器收到无效的响应。
- 503 Service Unavailable: 服务器当前无法处理请求，通常是临时的情况。

## MVC简介

- MVC全名是Model View Controller，是模型（Model）- 视图（View）- 控制器（Controller）的缩写。
- MVC是框架，是思想，不是设计模式。

### 模型（Model）

Model是应用程序中用于处理应用程序数据逻辑的部分

> 通常是数据库中的数据

### 视图（View）

View是应用程序中处理数据显示的部分

### 控制器（Controller）

Controller是应用程序中处理用户交互的部分

- 从Model中获取数据，并输入到View中
- 接收View中的用户操作，然后做出相应的响应

## Laravel核心目录

初始项目时，就存在的目录结构。

```text
www    WEB部署目录
├─app                         核心代码目录
│  ├─Console                  自定义 Artisan 命令
│  ├─Exceptions               异常处理程序
│  ├─Http                     控制器、中间件和请求
│  ├─Models                   模型
│  └─Providers                服务提供者
├─bootstrap                   文件引导框架目录
│  ├─cache                    框架生成的文件目录
│  └─app.php                  
├─config                      配置文件目录
│  ├─app.php                  
│  ├─auth.php                 
│  ├─broadcasting.php         
│  ├─cache.php                
│  ├─cors.php                 
│  ├─database.php             
│  ├─filesystems.php          
│  ├─hashing.php              
│  ├─logging.php              
│  ├─mail.php                 
│  ├─queue.php                
│  ├─sanctum.php              
│  ├─services.php             
│  ├─session.php              
│  └─view.php                 
├─database                    数据库文件相关目录
│  ├─Factories                模型工厂
│  ├─migrations               数据库迁移
│  └─seeders                  种子
├─public                      公共文件目录
├─resources                   资源文件目录
│  ├─css                      CSS文件
│  ├─js                       JavaScript文件
│  └─views                    视图文件
├─routes                      路由定义目录
│  ├─api.php                  
│  ├─channels.php             
│  ├─console.php              
│  └─web.php                  
├─storage                     文件缓存目录
│  ├─app                      
│  ├─framework                
│  │  ├─cache                 
│  │  ├─sessions              
│  │  ├─testing               
│  │  └─views                 
│  └─logs                     
├─tests                       自动化测试目录
│  ├─Feature                  
│  ├─Unit                     
│  ├─CreatesApplication.php   
│  └─TestCase.php             
├─vendor                      依赖项目录
├─.editorconfig               
├─.env                        
├─.env.example                
├─.gitattributes              
├─.gitignore                  
├─artisan                     
├─composer.json               
├─package.json                
├─phpunit.xml                 
├─README.md                   
└─vite.config.js              
```

## Laravel附属（可选）目录

通常是使用 `artisan` 命令创建才会创建。

```text
www    WEB部署目录
├─broadcasting                广播频道类目录
├─events                      事件类目录
├─jobs                        队列作业类目录
├─listeners                   事件侦听器类目录
├─mail                        电子邮件类目录
├─notifications               消息通知类目录
├─policies                    授权策略类目录
├─rules                       验证规则类目录
```

## 路由

- 简单的说就是将用户的请求转发给相应的程序进行处理

- 作用就是建立url和程序之间的映射

- 请求类型 get、post、put、patch、delete

## 服务提供者

- 服务提供者是所有 Laravel 应用程序的引导中心。你的应用程序，以及通过服务器引导的 Laravel 核心服务都是通过服务提供器引导。

- 但是，「引导」是什么意思呢？通常，我们可以理解为注册，比如注册服务容器绑定，事件监听器，中间件，甚至是路由。服务提供者是配置应用程序的中心。

- 所有的服务提供者都会继承`Illuminate\Support\ServiceProvider`类。大多服务提供者都包含一个 register 和一个`boot`方法。在`register`方法中，你只需要将服务绑定到`register`方法中， 你只需要 将服务绑定到**服务容器**。而不要尝试在`register`方法中注册任何监听器，路由，或者其他任何功能。

- 服务提供者确实是引导 Laravel 应用程序的关键。创建应用程序实例，注册服务提供者，并将请求传递给引导应用程序。就这么简单！

- 默认情况下，`AppServiceProvider`是空白的。这里是用于你添加应用自身的引导处理和服务容器绑定的一个非常棒的地方。在大型项目中，你可能希望创建多个服务提供者，每个服务提供者都为应用程序使用的特定服务提供更细粒度的引导。

## 服务容器

- Laravel 服务容器是一个用于管理类依赖以及实现依赖注入的强有力工具。依赖注入这个名词表面看起来花哨，实质上是指：通过构造函数，或者某些情况下通过「setter」方法将类依赖「注入」到类中。

- 几乎所有的服务容器绑定都会在 服务提供者 中注册

## Facades

- Laravel 的所有 Facades 都在`Illuminate\Support\Facades`命名空间中定义。

## 路由

所有 Laravel 路由都定义在你的路由文件中，它位于`routes`目录。这些文件会被你的应用程序中的 `App\Providers\RouteServiceProvider`自动加载。`routes/web.php`文件用于定义`web`界面的路由。这些路由被分配给 web 中间件组，它提供了 会话状态和 CSRF 保护等功能。定义在`routes/api.php`中的路由都是无状态的，并且被分配了`api`中间件组。

对于大多数应用程序，都是以在`routes/web.php`文件定义路由开始的。

定义在`routes/api.php`文件中的路由是被`RouteServiceProvider`嵌套在一个路由组内。 在这个路由组内，将自动应用`/api` URI 前缀，所以你无需手动将其应用于文件中的每个路由。你可以通过修改`RouteServiceProvider`类来修改前缀和其他路由组选项。

## 中间件

中间件提供了一种方便的机制来检查和过滤进入应用程序的 HTTP 请求。例如，Laravel 包含一个中间件，用于验证应用程序的用户是否经过身份验证。如果用户未通过身份验证，中间件会将用户重定向到应用程序的登录屏幕。 但是，如果用户通过了身份验证，中间件将允许请求进一步进入应用程序。

除了身份验证之外，还可以编写其他中间件来执行各种任务。例如，日志中间件可能会将所有传入请求记录到你的应用程序。Laravel 框架中包含了几个中间件，包括用于身份验证和 CSRF 保护的中间件。所有这些中间件都位于`app/Http/Middleware`目录中。

## CSRF 保护

跨站点请求伪造是一种恶意利用，利用这种手段，代表经过身份验证的用户执行未经授权的命令。

## 控制器

控制器并不是 **必需** 继承基础类。如果控制器没有继承基础类，你将无法使用一些便捷的功能，比如 `middleware` 和 `authorize` 方法。

## 请求

Laravel 的 `Illuminate\Http\Request` 类提供了一种面向对象的方式来与当前由应用程序处理的 HTTP 请求进行交互，并检索提交请求的输入内容、Cookie 和文件。

### 访问请求

要通过依赖注入获取当前的 HTTP 请求实例，您应该在路由闭包或控制器方法中导入 `Illuminate\Http\Request` 类。

## Blade 模板

在为自己的应用程序编写组件时，会在 `app/View/Components` 目录和 `resources/views/components` 目录中自动发现组件，因此通常不需要进一步的组件注册。

## Session

Session 的配置文件存储在`config/session.php`文件中。

默认情况下，Laravel 为绝大多数应用程序配置的 Session 驱动为 `file` 驱动，它适用于大多数程序.

在 Laravel 中有两种基本的 Session 使用方式：`全局session助手函数`和通过`Request`实例。

```php
// `Request`实例
$request->session()->get('key');

// 全局 Session 助手函数
$value = session('key', 'default');
```

> 通过 HTTP 请求实例与通过session助手函数方式使用 Session 之间没有实际区别。

### 存储数据

Session 里存储数据，你通常将使用 Request 实例中的`put`方法或者`session`助手函数：

```php
// 通过 Request 实例存储 ...
$request->session()->put('key', 'value');

// 通过全局 Session 助手函数存储 ...
session(['key' => 'value']);
```

## 日志

Laravel 日志基于「 通道 」。 每个通道代表一种写入日志信息的特定方式。 例如，`single` 通道是将日志写入到单个日志文件中。而 `slack` 通道是将日志发送到 Slack 上。 基于它们的重要程度，日志可以被写入到多个通道中去。

Laravel的日志服务采用Monolog

提供RFC 5424规范中定义的所有日志级别。按严重程度递减的顺序，这些日志级别是：**emergency，alert，critical，error，warning，notice，info和debug**。

```php
use Illuminate\Support\Facades\Log;

Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);
```

#### 按需通道

```php
use Illuminate\Support\Facades\Log;

Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
])->info('Something happened!');
```

## Artisan 命令行

### Tinker (REPL)

Laravel Tinker 是为 Laravel 提供的强大的 REPL（交互式解释器），由 PsySH(github.com/bobthecow/psysh) 驱动支持。

### 使用tinker

```shell
php artisan tinker
```

### 自定义命令

一般而言，命令保存在 `app/Console/Commands` 目录；不过，你可以自由选择命令的存储位置，只要它能够被 Composer 加载即可。

1. 生成命令

```shell
php artisan make:command SendEmails
```

2. 使用自定义命令

```shell
php artisan mail:send zhangsan
```

3. 文字输出格式

你可以使用 `line`，`info`，`comment`，`question` 和 `error` 方法，发送输出到控制台。 这些方法中的每一个都会使用合适的 ANSI 颜色以展示不同的用途。例如，我们要为用户展示一些常规信息。通常，`info` 将会以绿色文本在控制台展示。

```php
$this->info('The command was successful!');

// 输出单行空白...
$this->newLine();

// 输出三行空白...
$this->newLine(3);
```

### 注册命令

你的所有控制台命令都在您的应用程序的 `App\Console\Kernel` 类中注册，这是你的应用程序的「控制台内核」。

load 方法将扫描 `app/Console/Commands` 目录并自动将其中包含的每个命令注册到 Artisan。

### Stub 定制

使用以下 `stub:publish` 命令将最常见的 Stub 命令发布到你的应用程序中

```shell
php artisan stub:publish
```

已发布的 stub 将存放于你的应用根目录下的 `stubs` 目录中。对这些 stub 进行任何改动都将在你使用 Artisan `make` 命令生成相应的类的时候反映出来。

## 广播

### 配置

所有应用程序的事件广播配置都存储在`config/broadcasting.php`配置文件中。

Laravel支持多个广播驱动程序：`Pusher Channels`、`Redis`和用于本地开发和调试的`log`驱动程序。

此外，还包括一个`null`驱动程序，它允许你在测试期间完全禁用广播。

## 缓存

### 配置

缓存配置文件位于 `config/cache.php`。

Laravel 支持的缓存后端包括 `Memcached`、`Redis`、`DynamoDB`，以及现成的关系型数据库。此外，还支持基于`文件`的缓存驱动，以及方便自动化测试的缓存驱动 `array` 和 `null` 。

默认情况下，Laravel 配置为使用 `file` 缓存驱动，它将`序列化的缓存对象`存储在服务器的文件系统中。

## 事件系统

Laravel 的事件系统提供了一个简单的观察者模式的实现，允许你能够订阅和监听在你的应用中的发生的各种事件。事件类一般来说存储在 `app/Events` 目录，监听者的类存储在 `app/Listeners` 目录。不要担心在你的应用中没有看到这两个目录，因为通过 Artisan 命令行来创建事件和监听者的时候目录会同时被创建。

### 注册事件和监听器

在系统的服务提供者 `App\Providers\EventServiceProvider` 中提供了一个简单的方式来注册你所有的事件监听者。属性 `listen` 包含所有的事件 (作为键) 和对应的监听器 (值)。

### 生成事件和监听器

```shell
php artisan event:generate
```

### 事件的发现

你可以启用自动事件发现，而不是在 `EventServiceProvider` 的 `$listen` 数组中手动注册事件和侦听器。当事件发现启用，Laravel 将自动发现和注册你的事件和监听器扫描你的应用程序的 `Listeners` 目录。此外，在 `EventServiceProvider` 中列出的任何显式定义的事件仍将被注册。

Laravel 通过使用 PHP 的反射服务扫描监听器类来查找事件监听器。当 Laravel 发现任何以 `handle` 或 `__invoke` 开头的监听器类方法时，Laravel 会将这些方法注册为该方法签名中类型暗示的事件的事件监听器

默认情况下，应用程序 `app/listeners` 目录中的所有监听器都将被扫描。如果你想要定义更多的目录来扫描，你可以重写 `EventServiceProvider` 中的 `discoverEventsWithin` 方法

### 生产中的事件发现

在生产环境中，框架在每个请求上扫描所有监听器的效率并不高。因此，在你的部署过程中，你应该运行 `event:cache` Artisan 命令来缓存你的应用程序的所有事件和监听器清单。框架将使用该清单来加速事件注册过程。`event:clear` 命令可以用来销毁缓存。

## 文件存储

### 配置

Laravel 的文件系统配置文件位于 `config/filesystems.php`。

## HTTP 客户端

Laravel 为 `Guzzle HTTP` 客户端 提供了一套语义化且轻量的 API，让你可用快速地使用 HTTP 请求与其他 Web 应用进行通信。

默认情况下，Laravel 已经包含了 Guzzle 包。但如果你此前手动移除了它，你也可以通过 Composer 重新安装它：

```shell
composer require guzzlehttp/guzzle
```

### 创建请求

你可以使用 `Http` Facade 提供的 `head`, `get`, `post`, `put`, `patch`，以及 `delete` 方法来创建请求。首先，让我们先看一下如何发出一个基础的 GET 请求：

```php
use Illuminate\Support\Facades\Http;

$response = Http::get('http://example.com');
```

响应

```php
$response->body() : string;
$response->json($key = null, $default = null) : array|mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->status() : int;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;
```

状态码

```php
$response->ok() : bool;                  // 200 OK
$response->created() : bool;             // 201 Created
$response->accepted() : bool;            // 202 Accepted
$response->noContent() : bool;           // 204 No Content
$response->movedPermanently() : bool;    // 301 Moved Permanently
$response->found() : bool;               // 302 Found
$response->badRequest() : bool;          // 400 Bad Request
$response->unauthorized() : bool;        // 401 Unauthorized
$response->paymentRequired() : bool;     // 402 Payment Required
$response->forbidden() : bool;           // 403 Forbidden
$response->notFound() : bool;            // 404 Not Found
$response->requestTimeout() : bool;      // 408 Request Timeout
$response->conflict() : bool;            // 409 Conflict
$response->unprocessableEntity() : bool; // 422 Unprocessable Entity
$response->tooManyRequests() : bool;     // 429 Too Many Requests
$response->serverError() : bool;         // 500 Internal Server Error
```

## 本地化

> 默认情况下，Laravel 应用程序框架不包含 `lang` 目录。如果你想自定义 Laravel 的语言文件，可以通过 `lang:publish` Artisan 命令发布它们。

### 发布语言文件

```shell
php artisan lang:publish
```

### 配置语言环境

应用程序的默认语言存储在 `config/app.php` 配置文件的 `locale` 配置选项中。

## Mail

Laravel 基于 `Symfony Mailer` 组件提供了一个简洁、简单的邮件 API。

### 配置

Laravel 的邮件服务可以通过 `config/mail.php` 配置文件进行配置。

### 生成 Markdown 邮件

你可以在执行 `make:mail` 的 Artisan 命令时使用 `--markdown` 选项来生成一个 Markdown 格式模板的 mailable 类：

```shell
php artisan make:mail OrderShipped --markdown=emails.orders.shipped
```

### 编写 Markdown 邮件

Markdown mailable 类整合了 Markdown 语法和 Blade 组件，让你能够非常方便的使用 Laravel 预置的 UI 组件来构建邮件消息：

```text
<x-mail::message>
# 订单发货

你的订单已发货！

<x-mail::button :url="$url">
查看订单
</x-mail::button>

谢谢,<br>
{{ config('app.name') }}
</x-mail::message>
```

## 消息通知

### 生成消息

要生成具有相应 Markdown 模板的通知，可以使用 `make:notification` Artisan 命令的 `--markdown` 选项：

```shell
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid
```

## 进程管理

### 调用过程

在调用过程中，你可以使用 `进程管理` facade 提供的 `run` 和 `start` 方法。 `run` 方法将调用一个进程并等待进程执行完毕，而 `start` 方法用于异步进程执行。

```php
use Illuminate\Support\Facades\Process;

$result = Process::run('ls -la');

return $result->output();
```

## 队列

Laravel 队列的配置选项存储在 `config/queue.php` 文件中。

### 生成任务类

默认情况下，应用程序的所有的可排队任务都被存储在了 app/Jobs 目录中。如果 app/Jobs 目录不存在，当你运行 make:job Artisan 命令时，将会自动创建该目录：

```shell
php artisan make:job ProcessPodcast
```

### 最大尝试次数

指定任务可尝试的最大次数的其中一个方法是，通过 Artisan 命令行上的 `--tries` 开关。这将适用于调度作业的所有任务，除非正在处理的任务指定了最大尝试次数。

```shell
php artisan queue:work --tries=3
```

### 超时

任务可以运行的最大秒数可以使用 Artisan 命令行上的 `--timeout` 开关来指定

```shell
php artisan queue:work --timeout=30
```

### 错误处理

如果在处理任务时抛出异常，任务将自动释放回队列，以便再次尝试。 任务将继续发布，直到尝试达到你的应用程序允许的最大次数为止。最大尝试次数由 `queue:work` Artisan 命令中使用的 `--tries` 开关定义。或者，可以在任务类本身上定义最大尝试次数。

### 运行队列工作者

Laravel 包含一个 Artisan 命令，该命令将启动队列进程并在新任务被推送到队列时处理它们。 你可以使用 `queue:work` Artisan 命令运行任务进程。请注意，一旦 `queue:work` 命令启动，它将继续运行，直到手动停止或关闭终端：

```shell
php artisan queue:work
```

> 要保持 `queue:work` 进程在后台永久运行，你应该使用 `Supervisor` 等进程监视器来确保队列工作进程不会停止运行。

如果你希望处理的任务 ID 包含在命令的输出中，则可以在调用 q`ueue:work` 命令时包含 -v 标志：

```shell
php artisan queue:work -v
```

请记住，队列任务工作者是长期存在的进程，并将启动的应用程序状态存储在内存中。 因此，他们在启动后不会注意到你的代码库中的更改。 因此，在你的部署过程中，请务必**重新启动你的任务队列进程**。 此外，请记住，你的应用程序创建或修改的任何静态状态都不会在任务启动之间自动重置。

或者，你可以运行 `queue:listen` 命令。 使用 `queue:listen` 命令时，当你想要重新加载更新后的代码或重置应用程序状态时，无需手动重启 worker； 但是，此命令的效率明显低于 `queue:work` 命令：

```shell
php artisan queue:listen
```

### 队列进程 & 部署

由于队列任务是长期存在的进程，如果不重新启动，他们不会注意到代码的更改。因此，使用队列任务部署应用程序的最简单方法是在部署过程中重新启动任务。你可以通过发出 `queue:restart` 命令优雅地重新启动所有进程：

```shell
php artisan queue:restart
```

此命令将指示所有队列进程在处理完当前任务后正常退出，以免丢失现有任务。由于队列任务将在执行 `queue:restart` 命令时退出，你应该运行诸如 `Supervisor` 之类的进程管理器来自动重新启动队列任务。

### 进程超时

queue:work Artisan命令公开了一个--timeout选项。默认情况下，--timeout值为60秒。如果任务的处理时间超过超时值指定的秒数，则处理该任务的进程将退出并出现错误。通常，工作程序将由 `你的服务器上配置的进程管理器` 自动重新启动：

```shell
php artisan queue:work --timeout=60
```

### 重试失败的任务

要查看已插入到你的 `failed_jobs` 数据库表中的所有失败任务，你可以使用 `queue:failed` Artisan 命令：

```shell
php artisan queue:failed
```

`queue:failed` 命令将列出任务 ID、连接、队列、失败时间和有关任务的其他信息。任务 ID 可用于重试失败的任务。例如，要重试 ID 为 `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece` 的失败任务，请发出以下命令：

```shell
php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece
```

还可以重试指定队列的所有失败任务：

```shell
php artisan queue:retry --queue=name
```

重试所有失败任务，可以执行 `queue:retry` 命令，并将 `all` 作为 ID 传递：

```shell
php artisan queue:retry all
```

如果要删除指定的失败任务，可以使用 `queue:forget` 命令：

```shell
php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d
```

删除 `failed_jobs` 表中所有失败任务，可以使用 `queue:flush` 命令:

```shell
php artisan queue:flush
```

### 删除失败的任务

你可以通过调用 `queue:prune-failed` Artisan 命令删除应用程序的 `failed_jobs` 表中的所有记录：

```shell
php artisan queue:prune-failed
```

默认情况下，将删除所有超过 24 小时的失败任务记录，如果为命令提供 `--hours` 选项，则仅保留在过去 N 小时内插入的失败任务记录。例如，以下命令将删除超过 48 小时前插入的所有失败任务记录：

```shell
php artisan queue:prune-failed --hours=48
```

### 从队列中清除任务

如果你想从默认连接的默认队列中删除所有任务，你可以使用 `queue:clear` Artisan 命令来执行此操作：

```shell
php artisan queue:clear
```

你还可以提供 `connection` 参数和 `queue` 选项以从特定连接和队列中删除任务：

```shell
php artisan queue:clear redis --queue=emails
```

## 任务调度

Laravel 的命令行调度器允许你在 Laravel 中清晰明了地定义命令调度。在使用这个任务调度器时，你只需要在你的服务器上创建单个 Cron 入口。你的任务调度在 `app/Console/Kernel.php` 的 `schedule` 方法中进行定义。

## 身份认证

Laravel 的身份验证工具的核心是由「看守器」和「提供器」组成的。 看守器定义如何对每个请求的用户进行身份验证。例如，Laravel 附带了一个 `session` 守卫，它使用 session 和 cookie 来维护状态。

提供器定义如何从持久存储中检索用户。 Laravel 支持使用 Eloquent 和数据库查询构建器检索用户。

应用程序的身份验证配置文件位于 `config/auth.php`. 这个文件包含几个记载了的选项，用于调整 Laravel 身份验证服务的行为。

## 用户授权

Laravel 主要提供了两种授权操作的方法: `拦截器`和`策略`。 可以把拦截器（gates）和策略（policies）想象成路由和控制器。拦截器（Gates）提供了一种轻便的基于闭包函数的授权方法，像是路由。而策略（policies)，就像是一个控制器，对特定模型或资源，进行分组管理的逻辑规则。

### 拦截器 (Gates)

拦截器（Gates）是用来确定用户是否有权执行给定操作的闭包函数。默认条件下，拦截器（Gates）的使用，是在`App\Providers\AuthServiceProvider`类中的 `boot` 函数里来规定`Gate`规则。拦截器（Gates）始终接收用户实例为其第一个参数，并且可以选择性的接收其他参数，例如相关的 Eloquent 模型。

### 策略

策略是围绕特定模型或资源组织授权逻辑的类。

### 注册策略

注册策略是告知 Laravel 在授权针对给定模型类型的操作时使用哪个策略。

新的 Laravel 应用程序中包含的`App\Providers\AuthServiceProvider`包含一个`policies`属性，它将 Eloquent 模型映射到其相应的策略。 注册策略将指示 Laravel 在授权针对给定 Eloquent 模型的操作时使用哪个策略

### 策略自动发现

只要模型和策略遵循标准的 Laravel 命名约定，Laravel 就可以自动发现策略，而不是手动注册模型策略。具体来说，策略必须位于包含模型的目录或其上方的「Policies」目录中。

Laravel 将检查`app/Models/Policies`然后`app/Policies`中的策略。

此外，策略名称必须与模型名称匹配并具有「策略」后缀。 因此，`User`模型将对应于`UserPolicy`策略类。

## 加密解密

Laravel 的加密服务提供了一个简单、方便的接口，使用 OpenSSL 所提供的 AES-256 和 AES-128 加密和解密文本。所有 Laravel 加密的结果都会使用消息认证码 (MAC) 进行签名，因此一旦加密，其底层值就不能被修改或篡改。

### 配置

在使用 Laravel 的加密工具之前，你必须先设置 `config/app.php` 配置文件中的 `key` 配置项。该配置项由环境变量 `APP_KEY` 设定。你应当使用 `php artisan key:generate` 命令来生成该变量的值，key:generate 命令将使用 PHP 的安全随机字节生成器为你的应用程序构建加密安全密钥。通常情况下，在 Laravel 安装 中会为你生成 APP_KEY 环境变量的值。

```php
use Illuminate\Support\Facades\Crypt;

$string = 'token';
        $en = Crypt::encryptString($string);
        var_dump($en);
        // eyJpdiI6ImFSOFJPRnRpRnpvTEhSU2tOMFVpVEE9PSIsInZhbHVlIjoibktaTlhBVkxra0NFem1WUDBOekFGQT09IiwibWFjIjoiMjk2YTMwZGZjYmZjMTA1MGQxNGE3OWE3YjdhMDk2MmM1ZDUzY2ZlOGE3ODI0MGM2MmEzYzhjOThjNTJiN2U4ZiIsInRhZyI6IiJ9
        $de = Crypt::decryptString($en);
        var_dump($de);  // token
```

## 哈希

你可以在 `config/hashing.php` 配置文件中配置默认哈希驱动程序。目前有几个受支持的驱动程序：`Bcrypt` 和 `Argon2`（Argon2i 和 Argon2id 变体）。

```php
use Illuminate\Support\Facades\Hash;

// 哈希密码
Hash::make($request->newPassword);

// 调整 Bcrypt 加密系数
Hash::make('password', [
    'rounds' => 12,
]);

// 调整 Argon2 加密系数
Hash::make('password', [
    'memory' => 1024,
    'time' => 2,
    'threads' => 2,
]);

// 验证密码是否与哈希值相匹配
if (Hash::check('plain-text', $hashedPassword)) {
    // The passwords match...
}

// 确定密码是否需要重新哈希
if (Hash::needsRehash($hashed)) {
    $hashed = Hash::make('plain-text');
}
```

## 数据库

Laravel数据库服务的配置位于应用程序的`config/database.php`配置文件中。

## 数据库迁移

迁移类包含两个方法：`up` 和 `down` 。`up` 方法用于向数据库中添加新表、列或索引，而 down 方法用于撤销 `up` 方法执行的操作。.

## 数据填充

Laravel 内置了一个可为你的数据库填充测试数据的数据填充类。所有的数据填充类都应该放在 `database/seeds` 目录下。Laravel 默认定义了一个 `DatabaseSeeder` 类。通过这个类，你可以用 `call` 方法来运行其他的 `seed` 类，从而控制数据填充的顺序。

### 编写Seeders

生成的 seeders 都放在 `database/seeders` 目录下：

```shell
php artisan make:seeder UserSeeder
```

一个数据填充类默认只包含一个方法：`run` ，当执行 `db:seed` Artisan命令 时，被调用。在 `run` 方法中, 可以按需将数据插入数据库中。 也可以使用`查询构造器`来手动插入数据，或者可以使用 `Eloquent 数据工厂`。

### 运行Seeders

执行 `db:seed` Artisan 命令来为数据库填充数据。默认情况下，`db:seed` 命令会运行 `Database\Seeders\DatabaseSeeder` 类来调用其他数据填充类。当然，也可以使用 `--class` 选项来指定一个特定的填充类：

```shell
php artisan db:seed

php artisan db:seed --class=UserSeeder
```

你还可以使用 `migrate:fresh` 命令结合 `--seed` 选项，这将删除数据库中所有表并重新运行所有迁移。此命令对于完全重建数据库非常有用。 `--seeder` 选项可以用来指定要运行的填充文件：

```shell
php artisan migrate:fresh --seed

php artisan migrate:fresh --seed --seeder=UserSeeder
```

**在生产环境中强制运行填充**

一些填充操作可能会导致原有数据的更新或丢失。为了保护生产环境数据库的数据，在 `生产环境` 中运行填充命令前会进行确认。可以添加 `--force` 选项来强制运行填充命令：

```shell
php artisan db:seed --force
```

## Redis

`Redis` 是一个开源的, 高级键值对存储数据库。 保护的数据库类型有 `字符串`, `hash`, `列表`, `集合` 和 `有序集合`。

如果你不能安装 PHPRedis 扩展，你或许可以使用 composer 安装 predis/predis 包。Predis 是一个完全用 PHP 编写的 Redis 客户端，不需要任何额外的扩展：

```shell
composer require predis/predis
```

### 配置

在你的应用中配置 Redis 信息，你要在 `config/database.php` 文件中进行配置。

默认情况下，Redis 客户端使用 `tcp` 方案连接 Redis 服务器。另外，你也可以在你的 Redis 服务配置数组中指定一个 `scheme` 配置项，来使用 TLS/SSL 加密：

```shell
'redis' => [
    'default' => [
        'scheme' => 'tls',
    ],
],
```

## Eloquent ORM

### 生成模型类

由 `make:model` 命令生成的模型会被放置在 `app/Models` 目录下。

```shell
php artisan make:model Flight

# 在生成模型类的同时生成 数据库迁移， 可以使用 --migration 或 -m 选项
php artisan make:model Flight --migration
```

### UUID 与 ULID 键

你可以选择使用UUID，而不是使用自动递增的整数作为Elquent模型的主键。UUID是36个字符长的通用唯一字母数字标识符。

如果你希望模型使用UUID键而不是自动递增的整数键，可以在模型上使用 `Illuminate\Database\Eloquent\Concerns\HasUuids` trait，在此情况下应该确保模型具有 `UUID相等的主键列`:

### Events

Eloquent 模型触发几个事件，允许你挂接到模型生命周期的如下节点： `retrieved`、`creating`、`created`、`updating`、`updated`、`saving`、`saved`、`deleting`、`deleted`、`restoring`、`restored`、r`eplicating`。事件允许你每当特定模型保存或更新数据库时执行代码。每个事件通过其构造器接受模型实例。

当从数据库中检索到现有模型时，将调度 `retrived` 事件。 当一个新模型第一次被保存时，`creating` 和 `created` 事件将被触发。 `updating` / `updated` 事件将在修改现有模型并调用 `save` 方法时触发。`saving` / `saved` 事件将在创建或更新模型时触发 - 即使模型的属性没有更改。以`-ing`结尾的事件名称在模型的任何更改被持久化之前被调度，而以`-ed`结尾的事件在对模型的更改被持久化之后被调度。

要开始监听模型事件，请在 Eloquent 模型上定义一个 $dispatchesEvents 属性。此属性将 Eloquent 模型生命周期的各个点映射到你定义的事件类。每个模型事件类都应该通过其构造函数接收受影响的模型的实例

### 观察者

如果在一个模型上监听了多个事件，可以使用观察者来将这些监听器组织到一个单独的类中。观察者类的方法名映射到你希望监听的 Eloquent 事件。这些方法都以模型作为其唯一参数。`make:observer` Artisan 命令可以快速建立新的观察者类：

```shell
php artisan make:observer UserObserver --model=User
```

## 修改器 & 类型转换

当你在 Eloquent 模型实例中获取或设置某些属性值时，访问器和修改器允许你对 Eloquent 属性值进行格式化。例如，你可能需要使用 Laravel 加密器 来加密保存在数据库中的值，而在使用 Eloquent 模型访问该属性的时候自动进行解密其值。

或者，当通过 Eloquent 模型访问存储在数据库的 JSON 字符串时，你可能希望将其转换为数组。

### 属性转换

属性转换提供了类似于访问器和修改器的功能，且无需在模型上定义任何其他方法。模型中的 `$casts` 属性提供了一个便利的方法来将属性转换为常见的数据类型。

`$casts` 属性应是一个数组，且数组的键是那些需要被转换的属性名称，值则是你希望转换的数据类型。

### 自定义类型转换

Laravel 有多种内置的、有用的类型转换； 如果需要自定义强制转换类型。要创建一个类型转换，执行`make:cast`命令。 新的强制转换类将被放置在你的`app/Casts`目录中:

```shell
php artisan make:cast Json
```

## Eloquent 数据工厂

当测试你的应用程序或向数据库填充数据时，你可能需要插入一些记录到数据库中。Laravel 允许你使用模型工厂为每个 Eloquent 模型定义一组默认属性，而不是手动指定每个列的值。

### 创建工厂

```shell
php artisan make:factory PostFactory
```

新工厂类将被放置在你的 `database/factories` 目录中。

## 测试

默认情况下，你应用程序的`tests`目录下包含两个子目录：`Feature` 和 `Unit`。

### 创建测试

要创建新的测试用例，请使用Artisan 命令：`make:test`。 默认情况下，测试将放置在 `tests/Feature` 目录中

```shell
php artisan make:test UserTest
```

如果想在 `tests/Unit` 目录中创建一个测试，你可以在执行 `make:test` 命令时使用 `--unit` 选项：

```shell
php artisan make:test UserTest --unit
```

## Laravel Pint

Laravel Pint 是一款面向极简主义者的 PHP 代码风格固定工具。Pint 是建立在 PHP-CS-Fixer 基础上，使保持代码风格的整洁和一致变得简单。

### 安装

Pint 已包含在 Laravel 框架的最近版本中，所以无需安装。然而，对于旧的应用程序，你可以通过 Composer 安装 Laravel Pint：

```shell
composer require laravel/pint --dev
```

### 运行 Pint

可以通过调用你项目中的 vendor/bin 目录下的 pint 二进制文件来指示 Pint 修复代码风格问题：

```shell
./vendor/bin/pint
```

你也可以在特定的文件或目录上运行 Pint：

```shell
./vendor/bin/pint app/Models

./vendor/bin/pint app/Models/User.php
```

Pint 将显示它所更新的所有文件的详细列表。

```shell
./vendor/bin/pint -v
```

如果你只想 Pint 检查代码中风格是否有错误，而不实际更改文件，则可以使用 `--test` 选项：

```shell
./vendor/bin/pint --test
```

如果你希望 Pint 根据 Git 仅修改未提交更改的文件，你可以使用 --dirty 选项：

```shell
./vendor/bin/pint --dirty
```
